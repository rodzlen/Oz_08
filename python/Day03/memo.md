# Day03

## input 
- input은 기본적으로 str 자료형임 필요에 따라 형변환 해야함
- input은 띄어쓰기를 인식하지 않아서 .spilt() 써야함

**map()**
- 여러 값 형 변환 하게 해준다
q,w,e,r = map(int,input().split(' '))

**print** 
- sep, end 기능
print("asd","asd",sep="/") 
print("asd","asd","as", end="") 프린트 함수가 실행되고 줄바꿈 되는 걸 입력한 정보로 바꿈


## 형변환이 가능한 시퀀스 자료형 종류

**list()** 
- 원소들이 연속적으로 저장되는 형태의 자료형 -> 시퀀스 자료형 
- 형변환 하면 빈 리스트도 가능

연속된 숫자를 생산하는 기능
range(범위)
예시
a = list(range(1,10))
-----
#### list 요소 추가 제거 
**값 넣기**

insert(x, y): 원하는 곳에 값을 넣는다 
append(): 마지막에 값을 넣는다

**값 지우기**
del asd[x]

**값 바꾸기**
asd[x] = 데이터

**정렬**  - 반환값이 없다
.reverse() : 현재 순서 거꾸로
.sort() : 알파벳 순

**2차원 리스트**
a = [[],[]]

-----
**tuple**
- 사용 이유 
    1. 3GO(넣고,삭제하고, 바꾸고)가 불가능
        - 변경되면 안되는 변수를 건드리지 않게 (협업 시)
        - 변경되면 안되는 중요한 데이터(은행 계좌, 비밀번호 등) - 보안적으로 관리
    2. list보다 가볍다
        - Pyrthon은 동적 배열을 지원
            * list 자료형은 추가 할당을 진행할 메모리 크기를 더블링을 한다. 4, 8, 16, 32 ...
    3. list는 가변 tuple은 불변
        - 값이 고정되어야 하거나 작을 경우 tuple을 권장

        * 리스트처럼 요소를 일렬로 저장하지만 안에 저장된 요소를 변경, 추가, 삭제할수 없다.
        * 값을 추가, 삭제, 변경할 수 없기 때문에, 사용하지 못하는 메소드가 많다. 
        * tuple의 생성 방법 tuple = 값, 값 or tuple=(값, 값)
        * 튜플은 소괄호!!!!!()()()()()()()()()((((((()()()()()))))))
        인자값이 하나일때는 콤마 붙여야댐 안붙이면 int로 인식 언패킹 형식도 에외없다!!!

        list() 사용 가능 

**join**
- 요소들을 합쳐서 리턴
join('',asd)
-----
**dict**
- 여러 개의 값이 일렬로 정렬되면서도 값끼리의 연관성이 존재
- dict = {key  : value}
        * 시퀀스 데이터는는 인덱싱을 이용해 데이터를 찾았으나 dict은 x
        * dict은 키값을 입력하면 value를 리턴한다
        * key는 중복되면 안된다.
- 딕셔너리 만들기
    - 딕셔너리 = {}; 딕셔너리2 = {key : value}
- dict() 메서드를 이용해 만들기
    - 딕셔너리 = dict(key=value)
        * 메서드를 사용할 때는 파이썬 문법에 따라 함수 호출의 키워드 인자 문법으로 할당 연산자를 사용해야한다
            (다른 함수 호출 방식과 일관성을 유지할 수 있음)
        * 키값의 타입은 문자열만 가능하다
    - 딕셔너리 = dict(zip(['a','b','c','d'], [30,20,20,10]))
        zip매서드를 이용한 병렬 처리로 dict 자료형을 생성 가능하다

- **값 추가**
    - asd.update({key : value, key2 : value2})
- **값 변경**
    - asd["밸류를 변경할 키 값"] = "변경할 밸류 값" 
- **값 삭제** 
    - del asd["해당 키 값"] : 인덱싱이 안되기 때문에 인덱스 넘버는 적용이 안된다. key로만 접근하기 때문

**다양한 메소드**
asd.keys() : asd의 key 값만 반환
asd.values() : asd의 value 값만 반환
asd.items() : 각 항목을 반환

**dict의 인덱싱**
- 다른 시퀀스 자료형과는 다르게 인덱싱이 되지 않는다.
- list로 형변환을 하는데 이 때 .items()메소드를 사용하여 배열로 형변환 된다 
- 그럼 이제 인덱싱 가능 ㅋ

**이차원 dict**
코디 = {
    "모자" : {
        "캡" : "발렌시아",
        "비니" : "셀린느"
    },
    "상의" : {
        "후드" : "칼하트",
    }
}
코디[모자][캡] 이렇게 접근 
-----
**set()**
        - set은 수학의 집합을 의미
        - 딕셔너리와 같이 순서가 없다 : 중복된 값을 넣어도 단일로만 할당
        - 값의 중복을 허락하지 않는다
        - set 생성 방법도 {} 중괄호
        - 파이썬 스러운 코드를 짤 때 좋다
변수명 = set("asd")
이렇게 하면 'a', 's', 'd' 이런식으로 할당이 된다.

**추가하기**
- .add(추가할 데이터): 추가할 데이터에 들어가는 인자값 묶음 그대로 할당된다
- .update(추가할 데이터) : 추가할 데이터의 요소 하나하나 분해해서 할당된다

**삭제하기**
.remove(삭제할 데이터) : 전달받은 키워드 인자값을 삭제한다. 삭제할 데이터가 없는데 실행된 경우 오류를 일으킨다.
.discard(삭제할 데이터) : 똑같이 전달받은 키워드 인자값을 삭제하지만 삭제할 데이터가 없어도 오류를 일으키지 않는다.
.pop(데이터) : 해당 데이터를 반환하고 삭제한다.

**합집합**
.union(집합, 집합, ...)

**교집합**
.intersection(집합, 집합2, ...)

**차집합**
.difference(집합, 집합) : 집합에서 뺄 때 list나 tuple도 가능하다. 하지만 다른 자료형이 먼저 오면 안된다.